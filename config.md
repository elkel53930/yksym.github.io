

Try
===================

* タスクもMTGも会話も主張は文に書き出してprove 事前事後条件(状態)
* 議事録 + AIチケット化 + ボツ案原因
* 予定より遅れたら何が難しいかを、無理なら証拠を
* 同時並行するなら、必ず 定期3分 or 25分ルールで終わるタスクまで分解して処理した方が良い。
* 完全Doneする為にはどうすべきか。打ち切りや投機的対策・運用カバーも視野に入れる。




Keep
===================


いつも
------------------

* 焦らず、余裕を持ち、丁寧である
* 楽しめるように工夫する
* 他人からの承認よりも自己の成長を目的とする
* 周りの顔色や過去の自分の発言・行動に囚われず、正直である
* 安易に他人に頼らない
* 相手の環境を知り意図を読む(手伝う、学ぶ、説明、質疑応答）


現実世界へのアプローチ
---------------------

* 妥当性：仕様はどうなっているか？(契約:法人間、雇用、組織設計、コミュニケーションフロー)
* どんな問題があるのか(誰が何故困っているのか？）
* (要望や施策を考える前に)問題の本質はなにか、どうあるべきかを考える
* どんな施策があり、どれが最適か(施策をうつとのぞまぬ副作用が起きないか？)


コミュニケーション
---------------------

* テディベアシミュレーション
    * 20秒穴探し
    * 手短説明/質問/返答予想

* 受け答え
    * お返事は時間をかけても良い
    * 主張は要約する(すべきである.Yes/No. XXはYYです)
    * 根拠は最も分かりやすい具体例で(しないと誰が、どれくらいの確率で、どういう理由で、どれくらいうれしい/こまる)
    * 説明を補助する表・図・コードを用意する(特に比較する時)
    * 問題の原因を明確にした上で具体的な対策を提案する
    * 極力formalに記述.曖昧な言い回しは避ける
    * 用語の定義や用語間の関係を説明出来るようにする
    * 根拠として誰かが言ったはNG、客観的指標が必要

* 議論
    * その時点でフォーカスする問題や疑問をシンプルに表現する

* 仕事の受け渡し
    * 背景説明(出力を使って次に誰が何をするのか？そもそもの目的は？)
    * 事前条件(どこまで仮定していいの？リソースある？)
    * 事後条件(検証/review方法:SV、出力フォーマット)
    * 締切

* 質問
    * 誤解をさせない為に、背景事実をまず要約して述べてから質問しよう



考える
------------------

* 何が問題か(悪いのか)を具体的に説明する
    * モデル図を使って原因を調べて現象を説明出来るようにする
    * 時間・空間的な変動に注意
    * 数が不足なら num(x,t) = num(x,0) + integ(in(x,t) - out(x,t)) のグラフをかいて考察
    * そもそも解かなくて済む方法を探す

* どうあるべきか(ゴール・要望・仕様)を考える
    * 最適解が満たす条件(指標・制約)を決定する(too-much禁止)
    * 厄介な前提/制約を消す
    * 現状で何が出来るかからどの程度目的を達成できるかを議論するのもアリ

* もう一度問を立て直す
    * 〜であるか？ -> 〜が成立する条件は？ or 〜が成立しない例は？

* どう解くかを考える
    * 制約の強い所から決めて問題を簡単にする
    * 類似する小さい問題を考える(要素を減らす、抽象化する、制約を強める/弱める)
    * 図、表、グラフを駆使する
    * やろうとしていることと反対のことをしてみる(押してダメなら引いてみる)

* 考える時は正しい問と正しい絵を用意する
    * 現状(目標、背景、過程)理解を行う
    * 入力を一字一句丁寧に解釈する
    * 筋道は一歩ずつ通す
    * 「Aで問題ないか？〜できるか？」 => 「〜できるとはどういうことか？具体的な基準や仕様は？各ステップの異常は網羅+ハンドリング出来ているか？参考になる類似ケースはないか？」
    * 「AをBに変えても問題ないか?AでOKならBでもOKか？」 => 「AをBに変えると具体的に何が変わるか掘り下げる.バグも考慮する」
    * 「〜が問題」 => 「誰がどう困るのか？原因は？仕様かバグか？」
    * 「ピンとこない」 => 「具体的には何がある？」
    * 「リソース（人・モノ・金）が不足している」 => 「作業を削れないか? 代替・購買・レンタルでリソースを補えないか?」
    * 「AするとBになるから良い/悪い」 => 「Aした場合のみBになっているか？Aじゃない場合、AしなくてもBになっていないか？」
    * 「AするのにBは必要である」 => 「本当に必要最低限か？」

* リスク洗い出す
    * 分からないことについて分かってることを洗い出す
    * 発生確率が低ければ無視してよいかもしれない(その場合、信じるに至った経緯を明記する)
    * 軽減対策 or 発見の為の指標と早期対策
    * コアリスク：要件変更、仕様が間違い、モノが揃わない・作業終わらない

探す、選ぶ、評価する
---------------

* 決め方を決める
    * 重要なポリシーや基準を洗い出して枝刈りする(多少のリスクをとってでも目指すべき理想があるかもしれない)
    * 探索空間を定める(どこを探せばいいか？代用品は？途中で増える可能性もある)
    * 表を作って数値を入れると決まるようにする
    * 情報なければ一様分布/一様重み付け
    * ★ 時間内に決めるように段取りする
    * 2〜3個マイルストーン設けて、その時点で決め方（観点漏れや重み付け)についてチームに相談すること
        * 探索空間は網羅出来ないし、何を選んでもリスクはつきまとう
    * 困ったら どっちもやる or かたほうやって、だめならもう一個

* 買い物の場合、何回使うか？人件費などのランニングコストはどうか？を試算する

* ユースケースを網羅して、実際に使って問題がないことを確認する
    * 使えなかったら頭でシミュレーションしてみる

* 注意すること
    * Pros/Consはそれが活かせる/クリティカルであると説明出来ること
    * 迷ったらそもそも何のためにそれをするのかに戻ること
    * hack: 間を取る=折衷案


ゴール設定・見積もり
--------------------------------

* 受ける
    * そもそも作業としてやらなかった場合どうなるかを考えて、やるべきかどうかを決める
    * 本当に嬉しいか？手間かけても一度しか使わないなら意味はない

* ゴール設定
    * そのストーリーではなく最終的にどうなるのか、各人がどういう恩恵を受けるかを考え、分解して事前条件・事後条件を考え今回どうするか記述する
    * 具体的なユースケースでを決めると良い 「誰が、何をすると、どういうメリットがある(+並列動作対象は何か、異常系は？現場を具体的にイメージ)」
    * 要件と検証方法(終了時に解決/着手出来るモノは何か、機能ならその事前・事後条件や品質)
    * Xヶ月後にチームメンバが見なおして何をどこまでやるのか、その次何するのか具体的にイメージ出来るようなメモ
    * 分解時はビッグバン禁止。無駄な作業しない.一方向依存が良い.検証可能であること

* 作業の洗い出し + 見積り
    * 時間を決めてボトムアップとトップダウンを切り替えつつ筋道を定める
        * top-down: ユースケースから何が必要かを洗い出す(MECEにブレークダウン)
        * bottom-up: スケジュールや環境変化を考慮しつつ具体的にシミュレーションしていく(まず何する？次は？)
    * シミュレーション：手順を書き下す。その中の要素に対して、目的とする操作が出来る状態であること、それに必要な副次的な要素が必要かどうかを確認する
    * 各作業の入力と出力を具体化して、各作業が過不足なく接続されることを確認する
    * リスクは各過程の異常系を考える(満たせない事前条件や失敗やタイムアウト)
    * 作業が必要最小限に絞られているか確認する
    * 見積もりはnano%dayで出して、リスクからブレ幅を決める。(大体2倍以上になることが多い)

* スケジューリング
    * 関連する作業のスケジュールを調べる(依存、一括処理による効率化)
    * 同一期間中のイベントを調べる(リソースの競合)

* レビュー
    * 環境や各要素の状態とイベント網羅
    * リスク見積もり(異常系、怪我)
    * すでに達成出来てるような書き方はNG



作業する
-------------

* ゴールかいたらタスク全部きって並列度up + 仕様もパラで考えてもいい
* なぜやるのか、その作業しなくてもすむのか再考
* タスクレベルでもゴール設定 + 筋道定める
* 思考も個人ログに記録
* 一度試するor再現するのに時間がかかるものは最初からログ等で成功したか、失敗したら何が起こったか
* 理解してないものを危険な場所で触る恐怖。。頑張って理解しつつ練習環境で色々実験する時間を確保するしかないかなぁ



学ぶ
-----------

* 我が事のように聞いて、ステークホルダが何を質問するか予想する
* それは実務でどう使うのか？何故それは機能するのか？何故その理論や仕組みを採用したのか？他との違いは何か？

議事録
-------------

* 書記じゃなくても議事録はとる
* どんな会話もまず書いてから理解を試みる


預かる/返す/発注/受注
---------------------

 * 台帳にいつ、どこにしまったかor誰に渡したかを記述する(理由も)
 * callBackとポーリング用のtimerをセット


手伝う
------------------
 * 相手がやろうとしていることを理解する


動く/動かす
------------------

 * 移動先に求めるものがあるか？空きがあるか？
 * 物理シミュレーションして最適パスを計算する
 * 粘性・摩擦力や固定されているかどうかは見た目から分からないので慎重に扱う


作業記録
------------------

* 1時間に1度は何か書く。何をしたか、何が分かったか
* 作業に関係するアイデアや検討事項は、採用・非採用に関わらず結果・理由のログを残す
* 誰でも再現できるように環境と実行手順と日付の情報は残すこと

* 手順書に落とせるようにhistoryダンプする。なるべく自動化する。
* 証拠を残す(写真やらログやら)
* 作業前の状態が正常かどうか確認すること
* 類似するケースの手順を探す


仕様記述
--------------------

* 状態 x イベントを網羅チェック
* 数式や仕様記述言語で書いてから自然言語に変換すること(曖昧さがなくかつ実装と突き合わせやすい)
* 機能概要は要求に基づいて記述「～しない/する為の機能」
* 記述から検証が可能になっていること
* アルゴ記述は参考とし、事前・事後条件かいたほうがベター
* 仕様変更チケットにレビューしたい議題を入れてコンセンサスを取る

設計・実装
------------

* リファクタする場合は単体テスト作ってから
** 既存の単体テストがないならvalidationデータをいくつか作れば良い
* 非同期キャンセルはむずい。終了通知とキャンセル通知の行き違いが怖い

* 失敗(事前条件を満たしても事後条件みたせない)はさけられない場合もある(非決定性/IO/割り込み)
** 都合良く事前条件絞る + 失敗を適切にハンドリングすること

* アクターで順序をどう制御するか考えてみる。例えば同じスレッドがalloc/lockとrelease/unlockを行う方が大抵の場合望ましい

* 複雑なものは部分 or 階層に分けれるように工夫する


* 判断基準を明確にしないと、ぐちゃぐちゃになる。時間がないから楽をする、は一度認めると蟻の一穴。
** 後でリファクタ、は明確にいつするか積めないとまずやらないのですぐやった方がいい
** 例外は一個まで、二個目みつけたらリファクタとか

* 蓋(分岐条件)はゆるく(< よりも!=)、場合分けは最小かつオーバーラップしないように

* 代用/流用出来る仕組みや概念がないか検討する
* 逆や双対な概念の操作を試みる(離散・連続etc..)
* 要求に違反しない適切な制約をつけることでスッキリ記述出来ないか？
    * 関数を呼び出す回数や順序やタイミングを制限する
* 事前条件、事後条件、例外(事後条件満たせない場合）
* 内部の詳細がAPIや公開変数を通して外部に漏れていないか？
* 制御レベルの概念が汎用部品の中に浸透していないか？
* 関連する機能との相互作用を確認する

* コメントverification(状態で記述)
    * 何が変わるかだけでなく何が変わらないかも考える
    * 必ず変数の値域をかくことで特殊な場合を考慮する

review
-------

* 1tokenずつ追うこと（こぴぺミス防止もかねて)
    * resouce new/delete
    * overflow
    * branch/arg/return/error check

* 生存期間(作り方、捨て方、永続化、不変条件)

* 修正はそこだけで良いのか？(参照、名前の統一性、不変条件、etc...)
    * 関連する直近2コミット程度は辿って見直した方が無難

* 無駄に状態やメソッドを増やしていないか？(=消しても平気か？)役割と名前は適切か？
    * 状態の不変条件は変化していないか？変化ささえた場合は整合性は取れているか？
    * 関数の出入り部分、コンテキストスイッチが起こる場合(別スレッド、割り込み)

* 各ステップの異常系は正しくハンドル出来ているか？停止性は？ループの不変条件は？

* 並行に処理が行われ場合意図した順序に実行されるようになっているか？


デバッグ
-------------

* デバッグ中に見つけた不具合はデバッグ済んでから再現出来るか確認してからデバッグ着手
* 正しい絵(モデル)を得るには、思い込みに気付く必要がある
    * 絵に規則性があれば、その理由を証明する
    * 原理/定義からとにかく細かく要素を洗い出して相互関係や処理やデータの流れを追う
    * 各状態の組み合わせ、各イベントのズレについて注目する


ドキュメントレビュー
----------

* レイアウト崩れ + hash
* 版数とか見て、複数同じ言葉があれば、齟齬がないかassertすればいい。
* 基本的にある事柄で関係として結ばれていれば、それをチェックすればいい


