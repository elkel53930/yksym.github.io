

Try
===================



Keep
===================


いつも
------------------

* 焦らず、余裕を持ち、丁寧である
* 楽しめるように工夫する
* 他人からの承認よりも自己の成長を目的とする
* 周りの顔色や過去の自分の発言・行動に囚われず、正直である
* 安易に他人に頼らない
* 相手の環境を知り意図を読む(手伝う、学ぶ、説明、質疑応答）

コミュニケーション
---------------------

* テディベアシミュレーション
    * 20秒穴探し
    * 手短説明/質問/返答予想

* 受け答え
    * お返事は時間をかけても良い
    * 主張は要約する(すべきである.Yes/No. XXはYYです)
    * 根拠は最も分かりやすい具体例で(しないと誰が、どれくらいの確率で、どういう理由で、どれくらいうれしい/こまる)
    * 説明を補助する表・図・コードを用意する(特に比較する時)
    * 問題の原因を明確にした上で具体的な対策を提案する
    * 極力formalに記述.曖昧な言い回しは避ける
    * 用語の定義や用語間の関係を説明出来るようにする
    * 根拠として誰かが言ったはNG、客観的指標が必要

* 議論
    * その時点でフォーカスする問題や疑問をシンプルに表現する

* 仕事の受け渡し
    * 背景説明(出力を使って次に誰が何をするのか？そもそもの目的は？)
    * 事前条件(どこまで仮定していいの？リソースある？)
    * 事後条件(検証/review方法:SV、出力フォーマット)
    * 締切

* 質問
    * 誤解をさせない為に、背景事実をまず要約して述べてから質問しよう



考える
------------------

* 何が問題か(悪いのか)を具体的に説明する
    * モデル図を使って原因を調べて現象を説明出来るようにする
    * 時間・空間的な変動に注意
    * 数が不足なら num(x,t) = num(x,0) + integ(in(x,t) - out(x,t)) のグラフをかいて考察
    * そもそも解かなくて済む方法を探す

* どうあるべきか(ゴール・要望・仕様)を考える
    * 最適解が満たす条件(指標・制約)を決定する(too-much禁止)
    * 厄介な前提/制約を消す
    * 現状で何が出来るかからどの程度目的を達成できるかを議論するのもアリ

* もう一度問を立て直す
    * 〜であるか？ -> 〜が成立する条件は？ or 〜が成立しない例は？

* どう解くかを考える
    * 制約の強い所から決めて問題を簡単にする
    * 類似する小さい問題を考える(要素を減らす、抽象化する、制約を強める/弱める)
    * 図、表、グラフを駆使する
    * やろうとしていることと反対のことをしてみる(押してダメなら引いてみる)

* 考える時は正しい問と正しい絵を用意する
    * 現状(目標、背景、過程)理解を行う
    * 入力を一字一句丁寧に解釈する
    * 筋道は一歩ずつ通す
    * 「Aで問題ないか？〜できるか？」 => 「〜できるとはどういうことか？具体的な基準や仕様は？各ステップの異常は網羅+ハンドリング出来ているか？参考になる類似ケースはないか？」
    * 「AをBに変えても問題ないか?AでOKならBでもOKか？」 => 「AをBに変えると具体的に何が変わるか掘り下げる.バグも考慮する」
    * 「〜が問題」 => 「誰がどう困るのか？原因は？仕様かバグか？」
    * 「ピンとこない」 => 「具体的には何がある？」
    * 「リソース（人・モノ・金）が不足している」 => 「作業を削れないか? 代替・購買・レンタルでリソースを補えないか?」
    * 「AするとBになるから良い/悪い」 => 「Aした場合のみBになっているか？Aじゃない場合、AしなくてもBになっていないか？」
    * 「AするのにBは必要である」 => 「本当に必要最低限か？」

* リスク洗い出す
    * 分からないことについて分かってることを洗い出す
    * 発生確率が低ければ無視してよいかもしれない(その場合、信じるに至った経緯を明記する)
    * 軽減対策 or 発見の為の指標と早期対策
    * コアリスク：要件変更、仕様が間違い、モノが揃わない・作業終わらない

探す、選ぶ
---------------

* 決め方を決める
    * 重要なポリシーや基準を洗い出して枝刈りする(多少のリスクをとってでも目指すべき理想があるかもしれない)
    * 探索空間を定める(どこを探せばいいか？代用品は？途中で増える可能性もある)
    * 表を作って数値を入れると決まるようにする
    * 情報なければ一様分布/一様重み付け
    * ★ 時間内に決めるように段取りする
    * 2〜3個マイルストーン設けて、その時点で決め方（観点漏れや重み付け)についてチームに相談すること
        * 探索空間は網羅出来ないし、何を選んでもリスクはつきまとう
    * 困ったら どっちもやる or かたほうやって、だめならもう一個

* 買い物の場合、何回使うか？人件費などのランニングコストはどうか？を試算する

* 注意すること
    * Pros/Consはそれが活かせる/クリティカルであると説明出来ること
    * 迷ったらそもそも何のためにそれをするのかに戻ること
    * hack: 間を取る=折衷案


受注する/計画する/見積る/作業する
--------------------------------

* 受ける
    * 目的と内容を具体化する(ゴール設定、作業洗い出し)
    * そもそも作業としてやらなかった場合どうなるかを考えて、やるべきかどうかを決める
    * 見積もりして関連イベントとスケジュールを確認する
    * リスク/ショーストッパー(重要な前提条件)の伝達
    * 現在抱えてる仕事との関係を確認し、リスケや作業の見直しを行う

* ゴール設定
    * そのストーリーではなく最終的にどうなるのか、各人がどういう恩恵を受けるかを考え、その上で今回どこまで手に入るのかを記述する
    * 具体的なユースケースでを決めると良い 「誰が、何をすると、どういうメリットがある(+並列動作対象は何か、異常系は？現場を具体的にイメージ)」
    * どうあるべきかを考える(要件(品質含む)と検証方法は？QCDのどれに重きをおくのか？どんな技術を採用するのか？)
    * Xヶ月後にチームメンバが見なおして何をどこまでやるのか、その次何するのか具体的にイメージ出来るようなメモ

* レビュー
    * 環境や各要素の状態とイベント網羅
    * リスク見積もり(異常系、怪我)
    * すでに達成出来てるような書き方はNG

* 作業の洗い出
    * 時間を決めてボトムアップとトップダウンを切り替えつつ筋道を定める
        * top-down: ユースケースから何が必要かを洗い出す(MECEにブレークダウン)
        * bottom-up: スケジュールや環境変化を考慮しつつ具体的にシミュレーションしていく(まず何する？次は？)
    * シミュレーション：手順を書き下す。その中の要素に対して、目的とする操作が出来る状態であること、それに必要な副次的な要素が必要かどうかを確認する
    * 各作業の入力と出力を具体化して、各作業が過不足なく接続されることを確認する
    * リスクは各過程の異常系を考える(満たせない事前条件や失敗やタイムアウト)

* 見積もる
    * nano%dayで出して、リスクからブレ幅を決める。(大体2倍以上になることが多い)

* 作業する
    * ゴール設定 + 筋道定める
    * 思考も個人ログに記録



学ぶ
-----------

* 我が事のように聞いて、ステークホルダが何を質問するか予想する
* それは実務でどう使うのか？何故それは機能するのか？何故その理論や仕組みを採用したのか？他との違いは何か？

議事録
-------------

* 書記じゃなくても議事録はとる
* どんな会話もまず書いてから理解を試みる


預かる/返す/発注/受注
---------------------

 * 台帳にいつ、どこにしまったかor誰に渡したかを記述する(理由も)
 * callBackとポーリング用のtimerをセット


手伝う
------------------
 * 相手がやろうとしていることを理解する


動く/動かす
------------------

 * 移動先に求めるものがあるか？空きがあるか？
 * 物理シミュレーションして最適パスを計算する
 * 粘性・摩擦力や固定されているかどうかは見た目から分からないので慎重に扱う


作業記録
------------------

 * 1時間に1度は何か書く。何をしたか、何が分かったか
 * 作業に関係するアイデアや検討事項は、採用・非採用に関わらず結果・理由のログを残す
 * 誰でも再現できるように環境と実行手順と日付の情報は残すこと

 * 手順書に落とせるようにhistoryダンプする。なるべく自動化する。
 * 証拠を残す(写真やらログやら)
 * 作業前の状態が正常かどうか確認すること
 * 類似するケースの手順を探す


コードレビュー
------------

* レビュー対象について理解する + 関連する機能との相互作用を確認する
* 無駄に状態を増やしていないか？
* 状態の不変条件は変化していないか？変化ささえた場合は整合性は取れているか？
    * 関数の出入り部分、コンテキストスイッチが起こる場合(別スレッド、割り込み)
* 並行の場合意図した順序に実行されるようになっているか？
* 各ステップの異常系は正しくハンドル出来ているか？停止性は？ループの不変条件は？


デバッグ
-------------

* デバッグ中に見つけた不具合はデバッグ済んでから再現出来るか確認してからデバッグ着手
* 正しい絵(モデル)を得るには、思い込みに気付く必要がある
    * 絵に規則性があれば、その理由を証明する
    * 原理/定義からとにかく細かく要素を洗い出して相互関係や処理やデータの流れを追う
    * 各状態の組み合わせ、各イベントのズレについて注目する


