
いつも
====================

* 焦らず、余裕を持ち、丁寧で、正直である
* 楽しめるように工夫や調整をする(時間的余裕は必須)
* 他人からの承認よりも自己の成長を目的とする


理解する/説明する
=================

* (0) 自分の意見も他人の意見も基本的に鵜呑みにしない
* (1) 単純明快な問題設定(ゴール/条件)・図・具体例を用意する
* (2) 主張を一言に要約する(Yes/No. XXはYYです.・・・の場合が問題になる)
* (3) 絵と文におこして検証する
    * 用語の定義や関係は説明出来るか?曖昧さや定性的な修飾子はないか?
    * 導出は正しいか？暗黙的に使っている前提は妥当か(確度・過不足)?
    * 妥当な例はあるか？反例はないか?


要求する/される
===============

* 何がしたいか、何故したいかを単純明快にする(Goal)
    * 出力を使って次に誰が何をするのか？その次は？最後は？
    * 事前条件、事後条件(検証/review方法:SV、出力フォーマット)
    * 締切
* 作業が発生する場合：ブレークダウンして不足する情報や資源・リスク洗い出す
* 本当に自分が(簡単に)解決出来ない場合のみ要求を行う


計画する
====================

* (1) ゴールはユースケースでを決める「誰が、どういうインターフェースを使って、何を行うのか？」
* (2) どうあるべきかを考える(特にQCD)
* (3) どう進めるかを考える
    * システムやステークホルダーの絵を用意する
    * トップダウン：ユーザーの体験をベースに考える。H/W-setup, S/W-setup, GUI操作...etc...
    * ボトムアップ：まず何する？次は？（調査、設計、実装・テストで何をするのかブレストetc..)


解く
=====================

* (1) 問題は何か？何故それが問題なのか(重要度)？どの程度改善すべきかを第三者に説明出来るようにする(目的/現象/原因etc..)
    * 放置していいなら放置
* (2) どうあるべきかを考える
    * 最適解が満たす条件(モデル化・指標・制約)
    * 問題領域の外を見て、そもそもの目的や前提を崩す
      - そもそも解かなくて済む方法,厄介な前提/制約を消す
    * これが分からないなら現状で何が出来るかからどの程度目的を達成できるかを議論するのもアリ
* (3) どう解くかを考える
    * 複雑で混乱する場合は問題を限定して考える
      - モデルを簡単にする(要素を４つくらいに絞る)
      - 文章(ツリー)だけで整理しようとせず、モデル図、表、グラフを駆使する
      - 制約を追加/削除/緩める/強める(数値を上下させたり)
* (4) 網羅的に案をリストアップ
      - 技術的なネタならgoogle先生と論文と隣人に相談するのも良い(最低10分は自分で考えるべき)
      - 探しものならそれが存在しうる場所はどこか？代用品はないのか？
      - Pros/Cons

議事録
=================

* 書記じゃなくても議事録はとる
* どんな会話もまず書いてから理解を試みる
* テーマをTreeで表現し、現在の問題が何かを確認・共有出来るようにする


預かる/返す/発注/受注
========================

 * 台帳にいつ、どこにしまったかor誰に渡したかを記述する(理由も)
 * callBackとポーリング用のtimerをセット


動く/動かす
===========================

 * 移動先に求めるものがあるか？空きがあるか？
 * 物理シミュレーションして最適パスを計算する
 * 粘性・摩擦力や固定されているかどうかは見た目から分からないので慎重に扱う


作業記録
=====================

 * 作業に関係するアイデアは、採用・非採用に関わらず結果・理由のログを残す
 * 誰でも再現できるように環境と実行手順と日付の情報は残すこと


