
はすもく会のネタ
=================

はすもく会でポエムを書いてる。タイムリミットつきなのでだんだん雑になってるぞ！


背景
---------

最近、素人でも簡単かつ"意図した通りに"並行システムを記述出来るか、という試みについて触れる機会がありました。
最初はなんと無謀なと感じたのですが、記述環境と制約によっては案外イケるかも、という気がして少しずつ勉強することにしました。

とっかかりとなる疑問は2つです。

* a. 並行システムを"意図した通り"に記述するにはどうしたらいいか？そもそも何が問題なのか？
* b. 記述が"意図した通り"かを確認するにはどうしたらいいか？

まずは a. です。まだちゃんとお勉強＆サーベイしてないので、そもそも何が難しいのかについて整理された説明は出来ないですが、ざっとググった限りだとキーワードは非決定性のようです。
実際に私も注目するオブジェクトを操作する時に、自分以外の状態が分からないことで、起こりうる状態を全部考えて頭がパンクしたり、test-and-setをアトミックにし忘れてハマったりといった経験が多々あります。
まぁシングルスレッドでプログラミングしてる時もI/O使うということは環境との並行システム作っているのと同じなので、そういった意味でも馴染みのある問題とも言えるでしょう。

では実際、どう記述するのが良いんでしょうか？自傷力の高いmutexな共有メモリ方式は論外ですし、一時期持て囃されたErlangみたいなアクターモデルは非同期通信しかサポートしてないのは辛い。
Wikipediaの並行計算のページを見ると、π計算やら制約並行プログラミングやら論理並行プログラミングやら見知らぬ用語があります。まだまだお勉強することは沢山ありそうです。

「書くために読み、読むために書く」とも言いますし、勉強する前にまずは以前少し齧ったプロセス代数であるCSP(Communication Sequence Process)を使って自分なりの解法を探ってみました。


b. の方が a.よりも重要のように見えます。そもそも並行システムに限らず、自分の意図を誰かに伝える難しさといったら！
意図を正しく記述するには何かしらのトライ＆エラー工程は間違いなく必要でしょう。問題はエラーの判定とそのフィードバックをどうするかです。
これについては既存の素晴らしいアイデアが幾つか拝借すれば良さそうだと考えています。

* x. 具体的な振る舞いをユーザーに確認させる
    * Alloyのインスタンス生成機能みたいなの
    * 対話的なシミュレーター(Spinとかにあるやつ)
* y. 満たすべき命題をユーザーに確認させる
    * 命題をユーザーに書いてもらう
    * 命題をツールが提案してユーザーに判断してもらう(使ったことないけどHat や Freja の yes/no questionみたいなのをイメージしてます)

素人でも、と考えるとassert書かせるのは難易度高すぎと思うので一旦除外します。
状態爆発を考えると、命題書かせて証明させるくらいさせないと！という意見もあるのy. については魅力命題に網羅的なテストも難しい（レビューやモデル検査 思いもよらない


今回は、最初の一歩ということもあり簡単そうな対話的なシミュレーターでどこまで出来そうかを試してみました。


CSP
------

素人なりに参考書読んで学んだ内容(CSPの構文と意味)のふるゆわ解説記事を[ここ](csp_intro.md)に頑張って書きました。


対話的なシミュレーター
---------------------

CSPについて詳しくなりた〜いと思って勉強の為にHaskellでcsp-toyというのを自作しました。
それらしく動くようにはなったが大変だったし、自分でも読解不可能な糞コードになった(見たら発狂するレベル)。
あとHaskellは記号で [ や ] が使えないのが地味に痛い。

CSPにはフリーツールが幾つかあるので(FDRとかPATとか)、そこに対話的なシミュレーターがあるならそっち使うべき。


モデル化する対象システム
------------------------

Outlastのようなゲームを作ることを考えましょう。このゲームは謎の施設に侵入して敵から隠れながら秘密を暴くホラーゲームです。(リチャード・トレーガーというキャラの後ろ姿で有名でもあります)

ぱっと思いついたゲームシステムをざっと日本語で書き下してみます。

* 主人公が施設を探索しそこから恋人を連れて出口に移動すればゲームクリア
* 主人公が敵に見つかるとゲームオーバー
* 主人公はロッカーに隠れていれば、敵に見つからない
* 主人公は敵が近くにいる時だけロッカーに隠れることが出来、敵が近くにいなくなるまでロッカーからは出れない
* 恋人を連れているとロッカーに隠れることは出来ない
* 敵は動き続けていて、敵が主人公の近くにいると声や物音がする
* 敵が近くにいなければ見つかることはない
* ゲームスタート時は敵は近くにおらず、主人公はロッカーに入っていない

ではモデル化してみましょう。システムのイベントは以下の通りです。

    GameOver
    GameClear
    Contact    -- 敵に見つかった
    Hide       -- ロッカーに隠れた
    GetOut     -- ロッカーから出た
    TakeLover  -- 恋人を見つけて連れだした
    Exit       -- 外へ出た
    Enemy      -- 敵が近くにきた
    NoEnemy    -- 敵が近くからいなくなった


次に、これらのイベントがどう起こるのかをプロセス式で記述していみましょう

    GroundRule      := Exit -> GameClear -> Skip [] Contact -> GameOver -> Skip
    UserActionRule  := Hide -> GetOut -> UserActionRule [] TakeLover -> Exit -> Skip
    EnemyActionRule := Enemy -> (Hide -> NoEnemy -> GetOut -> EnemyActionRule [] Contact -> Skip) /\ Exit -> Skip
    System          := GroundRule || UserActionRule || EnemyActionRule

プログラマは基本的に操作と状態という視点で考えることが多いんですが、このようにイベント間の制約で書くことでも意外にスッキリ書けてビックリしました。 (個人的には正規表現を書いている気分になりました)


ゲームユーザーの振る舞い
------------------------


次にゲームユーザーの振る舞いも書いてみましょう。まずはユーザーが起こすイベントを定義します。


    GoToLover  -- 恋人の元へ向かう
    GoToLocker -- ロッカーに向かう
    GoToExit   -- 出口へ向かう

私だったら以下のようにプレイします。

* 恋人の所へ向かって、連れだして脱出する
* 敵の気配を感じたら、ロッカーを探して隠れる
* 見つかったら終了

これをプロセス式で書くと以下のようになります。

    UserProcess := (GoToLover -> TakeLover -> GoToExit -> Exit -> Skip  /\ Enemy -> GoToLocker -> Hide -> NoEnemy -> GetOut -> UserProcess)  /\ Contact -> Skip


システムプロセスとユーザープロセスを合成してシミュレーションしてみます

    UserProcess || SytemProcess

おっと、恋人を連れている時でも敵が近づいてきたらロッカーに隠れようとしました。中断の書き方が悪いようです。

    UserProcessBeforeTakeLover := (GoToLover -> TakeLover -> Skip /\ Enemy -> GoToLocker -> Hide -> NoEnemy -> GetOut -> UserProcess1)
    UserProcess                := (UserProcess1  ; (GoToExit -> Exit -> Skip  /\ Enemy -> Exit -> Skip))  /\ Contact -> Skip


これならうまくいきました。


所感(小並)
-------------

* 記述方法
    * CSP結構いいけど、上のユーザープロセスを素人さんが書けるかといわれたら難しそうだ（GUIを工夫すればワンチャンあるかも・・・）。
    * CSPは書き辛かったり面倒だったりする部分があった( -> Skip 沢山書かないといけないし、中断の扱い面倒。単に書き方が良くないのかなぁ・・・)

* 確認方法については、シミュレーションは色々気付きを与えてくれるが、大規模になってくるとキツイ。


今後(未定)
-----------

とりあえずサーベイしようかと。モデルだけでなくUIについても調べたい〜。
ドメインを限定することでどこまでユーザーにとって簡単になるかはまだまだ議論の余地がありそうです。それこそゲームとして楽しめるような難易度にしたい・・・


[2017-06-18 07:14]

